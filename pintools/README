To compile pintools, download and unpack the pin toolkit from the Intel's website: 
http://software.intel.com/en-us/articles/pin-a-dynamic-binary-instrumentation-tool

Set the PIN_ROOT environmental variable to point to the root  directory of the toolkit. 
Type 'make'.

The 'scripts' directory contains some example scripts for using the tools. They assume that 
the location of the pin.sh script (from the pin toolkit) is in your path. Take a look at the scripts
for an example of how to use each tool. The scripts rely on a variable CUSTOM_PINTOOLS_HOME, which points to vividperf/pintools.

Tool descriptions are provided below. The name in paretheses is the name of the script in the "scripts" directory that shows how to launch this tool. 


Tools:

=====================================================
memtracker.so (memtracker.sh, memtracker-with-gdb.sh)
=====================================================

This tool tracks memory accesses and memory allocations. It prints out a trace of allocation and access records. Here is an example of what you might see:

alloc: 0x00007f3a858d1c51 my_alloc 6 0x00007f3a7c000990 632 1 /cs/systems/home/fedorova/Work/my_example.c:380 BT_NODE * node

write: 6 0x00007f3a80d70960 8 main
write: 6 0x00007f3a80d70958 8 main
write: 6 0x00007f3a80d70950 8 main
write: 6 0x00007f3a80d70948 8 main

An allocation record gives us:
* The code address where the allocation was performed
* The name of the allocation function
* The ID of the thread that performed the allocation
* The allocated address
* The size of the allocation
* The number of allocated objects (for functions like calloc)
* The location in the source code
* Variable type (optional)
* Variable name

Allocation records are printed only if the debug information is available. 

The access record gives us:
* The type of an access (read or write)
* The ID of the thread that performed the access
* The address that was accessed
* The size of the access
* The name of the function that performed the access.

HOW TO USE THE TOOL:

To see how to launch the tool, take a look at the script memtracker.sh for an example.

If you want to know the types of allocated variables, you need to run with gdb and use the script memtracker-with-gdb.sh for an example. 

The tool assumes that the user provides two input files: alloc.in and memtracker.in. These are the file names assumed by default, and their assumed location is the same directory where the tool is invoked. 

alloc.in provides a list of alloc functions that you want to track. See a sample alloc.in in this repository (scripts directory) for the explanation of the expected format. 

The other file, memtracker.in, tells the tool the names of the functions in which you want to track the memory accesses. If you want to track everything, this file needs to contain a line with a '*' on it and nothing else. If you do not want to trace the entire program, but isolate your analysis to a problematic function (or functions), specify the function names you want to track, one per line. Lines starting with a '#' are ignored, so you can add comments on lines prefixed with a '#'.  See a sample memtracker.in in this repository (scripts directory) for the explanation of the expected format. 

HOW THE TOOL OBTAINS VARIABLE NAMES AND TYPES:

We get the name of the allocated variable by parsing the source file. The source location of the call to the alloc function can be obtained from within a Pintool. In most cases, the name of the variable is sufficient to identify the allocated object, because most programmers give their variables intuitive names. For instance, if you called a variable "node", you can guess that it is of type "BT_NODE", if this type is defined in your program. However, if desired, we can also obtain variable types. 

The way we get the type of the allocated variable is kind of arcane and ugly. I think this needs to be redesigned, but I do not have time, so here it is. Basically, the most quick and dirty way to implement this was to get the type via gdb, by using it's "whatis" command. We use gdb as follows:

(See memtracker-with-gdb.sh for an actual example.)

1) Start a gdb session providing the application binary as the argument and set it up so it reads its command from a file gdb-cmd.txt.
2) Concurrently have the memtracker launch the application using the "appdebug" mode, that is,
allowing gdb to attach to the application that is running inder a pintool.
3) Pipe the output from memtracker to the python script called memtracker-gdb-driver.py: let us call
it simply the GDB driver.
4) The GDB driver will take gdb commands from the tool's output (anything prefixed with "gdb:",
plus the initial pintool message specifying on which port to attach to the application)
and will write them to gdb-cmd.txt.
5) The GDB session will take the commands and execute them. 

We set a gdb breakpoint before every memory allocation function. Once that breakpoint is hit, we parse the source to find out the name of the variable, let's call it "varname", and then pass to gdb the command:

   whatis varname

Gdb then outputs the type of the variable to the file gdb-out.txt.
If the tool already asked gdb for a variable type, it doesn't ask it again, because we already have that information. 

At the end of the run, the script memtracker-process-raw.py takes the files log.txt (which is where memtracker prints allocation records -- that file contains everything except variable types) and gdb-out.txt (which contains variable types) and merges them into a unified data structure. 

So you can see how arcane this is. Doing this dance with gdb is also a huge hit on the tool's performance. A much better way would be to learn the variable type by doing more parsing on the source file, but I do not plan to do this, because I believe that in most cases knowing variable type does not buy us much once we know the variable name. Plus, I don't have time. So there you have it. 

IMPORTANT FEATURES:

Apart from the gdb madness, the tool has some nice features enabling it to work with real productioncode. 

* It does not require changes to the source code of your program. 
* It can track alternative alloc functions (not just malloc). In the input file (default is alloc.in) you specify the names of the allocation functions you want to track and their prototypes. So if your allocation function allocates multiple items at once (like calloc) or puts the allocated address in the in-out pointer argument -- memtracker supports that. Read an example file alloc.in to understand how to specify the allocation functions. 

Sometimes your alloc function might be wrapped in a macro, possibly giving this function an alternative prototype. You need to specify all such alternative prototypes for a function in alloc.in, otherwise memtracker will not be able to parse the variable name in cases where the allocation function is invoked via a macro.


==================
null.so (null.sh)
==================
This tool simply makes pin launch your program. It is used to measure the overhead on your program from running under pin. The overhead should be negligible for long-running programs. 

===========================
procinstr.so (procinstr.sh)
===========================
This tool instruments the functions of your choice with timing and outputs the average number of nanoseconds per invocation to the output file (procinstr.out by default). You must specify the functions to instrument in a config file. 

-i <input file|procnames.in> -- this file specifies the names of the procedures that will be
   	  		     instrumented (procnames.in by default). A sample procnames.in file 
			     is provided in the scripts directory.

-o <output file|procinstr.out> -- this configuration option specifies the output file where
   	   		       the instrumentation results will be placed. 
			       procinstr.out is the default. 

===========================================
showprocs-dynamic.so (showprocs-dynamic.sh)
===========================================
This tool interposes on all the functions in your binary, counts the number of times they are executed and outputs to the file only those functions that were actually invoked along with their invocation counts. The default output file is procs-dynamic.out, but you can specify your own as the script shows. Knowing the function names in your image is useful when deciding which functions you want to instrument, because compilers sometimes modify function names from their names in the program. 

-o <output file|procs-dynamic.out> -- this configuration option specifies the output file where
   	   			   the procedures will be put. procs-dynamic.out is the default. 

==========================================
showprocs-static.so (showprocs-static.sh)
==========================================
This tool loads the binary images required by the target program and outputs into a file all the functions contained within the images. The default output file is procs-static.out, but you can specify your own as the script shows. Knowing the function names in your image is useful when deciding which functions you want to instrument, because compilers sometimes modify function names from their names in the program. 

-o <output file|procs-static.out> -- this configuration option specifies the output file where
   	   			  the procedures will be put. procs-static.out is the default. 

==========================================
straggler-catcher.so (straggler-catcher.sh)
==========================================
This tool detects functions that are taking too long to complete. These functions are called "stragglers", hence the name straggler-catcher. It works by instrumenting the functions of interest and monitoring their completion times. The completion times are monitored inline (checked on function exit) and in a separate thread. So if a function is stuck sleeping, and hence taking too long to run, the tool will also detect that. Upon detection of a straggler the tool invokes a user defined shell script. 

-i <config file|stragglers.in> -- a configuration file that provides *straggler definitions*, 
   	   		       i.e., tells the script which functions to watch and their latency thresholds. 
			       The latency threshold tells the tool how long the function
			       must take to run before it is considered a straggler. 
			       Format: on each line speciy: <func> <number> <time unit>, as in:

			       myfunc  10 ms

			       which means that myfunc should be flagged as a straggler
			       if it takes more than 10ms to complete. Supported time units
			       are: ns, us, ms, s.
. 

-s <script|my_script.sh> -- this script is invoked every time we catch a straggler. The script
   			 is written by the user. The tool passes the following arguments
			 to the script: application pid, function name, elapsed time in 
			 nanoseconds and optionally a funciton trace (see below). An example 
			 my_script.sh that simply prints the arguments provided by the tool 
			 is provided in the scripts directory.

-t <time in ms|1000> -- this tells us how often the checker thread inside the tool should
   	    	     	wake up to check for stragglers. This time interval should be 
			provided in milliseconds, and the default is 1000. 


-trace <0 or 1 | 0> -- providing a "1" with this option enables recording all functions called 
       	       	       within a straggler function. Once the straggler is caught, the trace
		       will be supplied as an argument to the user-defined script, which can 
		       display the trace to the user. See my_script.sh in the 'scripts' directory
		       for an example.