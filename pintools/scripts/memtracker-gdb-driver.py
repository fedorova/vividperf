#!/usr/bin/python -tt

help = """This script takes the output generated by the Pin memtracker tool
and feeds it into the concurrently running gdb session. It drives the gdb
session to stop the program at the right places and output the debugging
information that we require -- to find out the types of the allocated
memory addresses. 

There are two optional arguments: 

(1) the name of the file where we will output the gdb commands 
(gdb-cmd.txt by default)

(2) the name of the log file where we will put a copy of all 
the output generated by the memtracker pintool (log.txt by default)

"""


from os import system
import os.path
import re
import sys
from sys import stdin
from optparse import OptionParser
from threading import Thread

breakMainHit = False;
bufferedCommands = [];

###
def checkIfBreakMainAndCont(fileGdbOut, fdGdbCmd):

    fdGdbOut = open(fileGdbOut, "r");

    global breakMainHit;
    global bufferedCommands;

    times = 0;
    printInterval = 1000000;

    # Check if GDB has hit the breakpoint on main()
    # If so, we need to let it continue
    #
    while not breakMainHit:
        times = times + 1;
        matches = []
        reg = re.compile("Breakpoint.*in main")

        filetext = fdGdbOut.read()
        matches = reg.findall(filetext)

        if(len(matches) > 0):
            print "Hit breakpoint on main()"

            # Send GDB all the bufferd commands
            for command in bufferedCommands:
                fdGdbCmd.write(command);

            fdGdbCmd.write("cont\n");
            fdGdbCmd.flush()
            breakMainHit = True;
        else:
            if(times%printInterval == 0):
                print "No breakpoint in main yet"

    fdGdbOut.close()

###
def doLoop(fdGdbCmd, fdGdbOut, fdLog):

    doneString = "PR DONE";
    GDB_CMD_PFX = "gdb:";
    global bufferedCommands;

    while True:

        line = stdin.readline()
        print 'driver: ' + line
        fdLog.write(line)
        fdLog.flush()

        if doneString in line:
            fdGdbCmd.write("quit\n");
            fdGdbCmd.flush()
            return;


        # This is the gdb attach command that
        # the pintool outputs. Send it to 
        # the gdb. Then we also need to tell gdb to 
        # continue execution. 
        #
        if "target remote :" in line:
            fdGdbCmd.write(line)
            fdGdbCmd.write("break main\n")
            fdGdbCmd.write("cont\n");
            fdGdbCmd.flush()

        # These are the gdb commands passed to us
        # by the pin tool
        #
        if (GDB_CMD_PFX in line and line.index(GDB_CMD_PFX) == 0):
            command = line.lstrip(GDB_CMD_PFX);
            print "gdb command: " + command

            # Buffer all the debugger commands until we
            # begin executing main. This is for performance
            # optimization, because if we are tracking malloc
            # we will hit lots of breakpoints before main even
            # runs, and we are most likely not interested in those
            # allocations.
            #
            if(not breakMainHit):
                bufferedCommands.append(command)
            else:
                fdGdbCmd.write(command)
                fdGdbCmd.flush()
            


###
def main():

    parser = OptionParser()
    parser.add_option("-c", "--cmd", action="store", type="string", 
                      dest="gdb_cmd_file",
                      help="File for gdb commands", 
                      default="gdb-commands.txt")
    parser.add_option("-l", "--log", dest="log_file",
                      help="Output log file", action="store", type="string", 
                      default = "log.txt");

    parser.add_option("-g", "--gdb", dest="gdb_output_file",
                      help="GDB output file", action="store", type="string", 
                      default = "gdb-out.txt");

    
    (options, args) = parser.parse_args()

    if not os.path.exists(options.gdb_cmd_file):
        print 'Cannot open file ' + options.gdb_cmd_file;
        sys.exit(1);
    fdGdbCmd = open(options.gdb_cmd_file, "a");

    if not os.path.exists(options.gdb_output_file):
        print 'Cannot open file ' + options.gdb_output_file;
        sys.exit(1);
    fdGdbOut = open(options.gdb_output_file, "r");

    fdLog = open(options.log_file, "w+");

    print "GDB command file: " + options.gdb_cmd_file
    print "GDB output file: " + options.gdb_output_file
    print "Log file: " + options.log_file

    # Start the thread that will check if the
    # application has hit the breakpoint in main
    # and will let it continue if so. 
    t = Thread(target = checkIfBreakMainAndCont, args=(options.gdb_output_file,fdGdbCmd));
    t.start()

    doLoop(fdGdbCmd, fdGdbOut, fdLog);

    print "Python GDB Driver Exiting"
    sys.exit();

if __name__ == '__main__':
    main()
